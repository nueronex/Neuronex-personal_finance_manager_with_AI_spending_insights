import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from datetime import datetime
from typing import Tuple, List, Dict


def _prepare(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    if 'date' in df.columns:
        df['date'] = pd.to_datetime(df['date'])
    else:
        raise ValueError("DataFrame must have a 'date' column")
    if 'amount' not in df.columns:
        raise ValueError("DataFrame must have an 'amount' column")
    # Normalize: treat expenses as positive amounts for analysis if they are negative
    # If you want to keep sign semantics, adjust accordingly.
    df['amount_abs'] = df['amount'].abs()
    # ensure category exists
    if 'category' not in df.columns:
        df['category'] = 'uncategorized'
    return df


def monthly_summary(df: pd.DataFrame) -> pd.DataFrame:
    """Return monthly totals: income, expense, net, saving_rate."""
    df = _prepare(df)
    df['year_month'] = df['date'].dt.to_period('M')
    # assume positive = expense or use 'type' column if present
    if 'type' in df.columns:
        income = df[df['type'] == 'income'].groupby('year_month')['amount'].sum()
        expense = df[df['type'] == 'expense'].groupby('year_month')['amount_abs'].sum()
    else:
        # Heuristic: treat positive amounts as expense if majority positive; otherwise user should use 'type'
        income = df[df['amount'] > 0].groupby('year_month')['amount'].sum()
        expense = df[df['amount'] < 0].groupby('year_month')['amount'].apply(lambda s: s.abs().sum())
        # If no negatives, treat amount_abs with separate source - fallback:
        if expense.empty:
            expense = df.groupby('year_month')['amount_abs'].sum()  # treat everything as expense (for demo)
            income = pd.Series(dtype=float)
    months = sorted(df['year_month'].unique())
    rows = []
    for m in months:
        inc = float(income.get(m, 0.0))
        exp = float(expense.get(m, 0.0))
        net = inc - exp
        saving_rate = None
        if inc > 0:
            saving_rate = (inc - exp) / inc
        rows.append({'month': str(m), 'income': inc, 'expense': exp, 'net': net, 'saving_rate': saving_rate})
    return pd.DataFrame(rows)


def category_breakdown(df: pd.DataFrame, period: str = 'M') -> pd.DataFrame:
    """Category totals for given period. period param uses pandas offset alias ('M' monthly, 'W' weekly)."""
    df = _prepare(df)
    df['period'] = df['date'].dt.to_period(period)
    gb = df.groupby(['period', 'category'])['amount_abs'].sum().reset_index()
    # Pivot to have categories columns optional, but return grouped listing
    return gb.sort_values(['period', 'amount_abs'], ascending=[True, False])


def detect_anomalies(df: pd.DataFrame, z_thresh: float = 3.0) -> pd.DataFrame:
    """
    Simple anomaly detection using z-score on daily spending totals.
    Returns detected anomaly rows with z-score.
    """
    df = _prepare(df)
    # daily totals
    daily = df.groupby(df['date'].dt.date)['amount_abs'].sum().reset_index()
    daily.columns = ['date', 'daily_total']
    mu = daily['daily_total'].mean()
    sigma = daily['daily_total'].std(ddof=0) if daily['daily_total'].std(ddof=0) > 0 else 1.0
    daily['z_score'] = (daily['daily_total'] - mu) / sigma
    anomalies = daily[abs(daily['z_score']) >= z_thresh].copy()
    return anomalies.sort_values('z_score', ascending=False)
    anomalies = routine[(daily['z score'])]


def forecast_next_period(df: pd.DataFrame, periods: int = 1) -> Dict[str, float]:
    """
    Simple linear-regression forecast on monthly expense totals.
    Returns dict of {period_str: forecast_amount} for next `periods` months.
    """
    df = _prepare(df)
    df['year_month'] = df['date'].dt.to_period('M')
    monthly = df.groupby('year_month')['amount_abs'].sum().reset_index()
    # Need numeric X (months since epoch)
    monthly['month_idx'] = (monthly['year_month'].dt.year * 12 + monthly['year_month'].dt.month)
    X = monthly[['month_idx']].values
    y = monthly['amount_abs'].values
    if len(X) < 2:
        # Not enough data: return last month as naive forecast
        last = float(y[-1]) if len(y) > 0 else 0.0
        next_period = (monthly['year_month'].iloc[-1] + 1).strftime('%Y-%m') if len(monthly) > 0 else datetime.today().strftime('%Y-%m')
        return {next_period: last}
    model = LinearRegression().fit(X, y)
    last_idx = monthly['month_idx'].iloc[-1]
    forecasts = {}
    for i in range(1, periods + 1):
        idx = last_idx + i
        pred = float(model.predict(np.array([[idx]]))[0])
        # convert idx back to year-month string
        year = idx // 12
        month = idx % 12
        # handle month 0 case (because month_idx formula)
        if month == 0:
            year -= 1
            month = 12
        period_str = f"{year:04d}-{month:02d}"
        forecasts[period_str] = max(pred, 0.0)
    return forecasts


def generate_recommendations(summary_df: pd.DataFrame,
                             category_df: pd.DataFrame,
                             anomalies_df: pd.DataFrame) -> List[str]:

    recs = []


    if not summary_df.empty:
        latest = summary_df.iloc[-1]
        if latest['income'] and latest['income'] > 0:
            sr = latest['saving_rate']
            if sr is None:
                pass
            elif sr < 0:
                recs.append(f"You're overspending in {latest['month']}. Try cutting discretionary costs by 10–20%.")
            elif sr < 0.1:
                recs.append(f"Your saving rate for {latest['month']} is low ({sr:.0%}). Consider a small budget for dining out or subscriptions.")
            else:
                recs.append(f"Good job — saving rate for {latest['month']} is {sr:.0%}. Keep it up!")
